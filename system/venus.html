<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Venus 8K Surface & Atmosphere View</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:Arial,Helvetica,sans-serif;}
canvas{display:block;}
#ui{
    position:absolute;bottom:20px;left:20px;z-index:10;
    color:#fff;background:rgba(0,0,0,0.45);
    backdrop-filter:blur(6px);
    padding:15px 20px;border-radius:10px;width:280px;
    line-height:1.5em;
}
#ui h2{margin:5px 0;font-size:20px;color:#ffd27f;}
#ui label,#ui input,#ui button{font-size:15px;color:#fff;}
#ui button{
    background:#444;border:1px solid #888;border-radius:6px;
    padding:5px 10px;margin-top:6px;cursor:pointer;
}
#ui button:hover{background:#666;}
#ui small{color:#ccc;}
</style>
</head>
<body>
<div id="ui">
    <h2>ðŸŒ• Venus System</h2>
    <p><b>Rotation Period:</b> â‰ˆ 243 Earth days (retrograde)</p>
    <label><input type="checkbox" id="autoRotate" checked> Auto Rotate</label><br>
    <label>Rotation Speed: <input type="range" id="speedSlider" min="0" max="5" value="1" step="0.1"></label><br>
    <button id="resetCam">Reset View</button><br>
    <button id="toggleView" disabled>Loading textures...</button><br>
    <small>Use mouse to rotate / scroll to zoom</small>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// camera rendering
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// lighting
const sunLight = new THREE.DirectionalLight(0xffe0b2,2);
sunLight.position.set(8,2,10);
scene.add(sunLight);
scene.add(new THREE.AmbientLight(0x302010,0.6));

//venus
const venusGeo = new THREE.SphereGeometry(5,256,256);
const venusMat = new THREE.MeshPhongMaterial({shininess:4});
const venus = new THREE.Mesh(venusGeo,venusMat);
scene.add(venus);

// textures
let surfaceTexture, atmosphereTexture;
const loader = new THREE.TextureLoader();

let texturesLoaded = 0;
function onTextureLoaded(tex, type){
    tex.colorSpace = THREE.SRGBColorSpace;
    if(type === 'surface') surfaceTexture = tex;
    else atmosphereTexture = tex;

    texturesLoaded++;
    if(texturesLoaded === 2){ // both textures loaded
        venusMat.map = surfaceTexture;
        venusMat.needsUpdate = true;
        toggleBtn.disabled = false;
        toggleBtn.innerText = "Switch to Atmosphere View";
    }
}

// venus surface loader
loader.load(
  "https://upload.wikimedia.org/wikipedia/commons/7/73/Solarsystemscope_texture_8k_venus_surface.jpg",
  tex => onTextureLoaded(tex,'surface')
);

// venus atmosphere loader
loader.load(
  "https://upload.wikimedia.org/wikipedia/commons/e/e5/Solarsystemscope_texture_8k_venus_atmosphere.jpg",
  tex => onTextureLoaded(tex,'atmosphere')
);

// glowing atmosphere
const glow = new THREE.Mesh(
    new THREE.SphereGeometry(5.15,64,64),
    new THREE.MeshPhongMaterial({color:0xffc88a,transparent:true,opacity:0.08})
);
scene.add(glow);
glow.visible = false;

// background stars
const starsGeo = new THREE.BufferGeometry();
const count=6000,pos=new Float32Array(count*3);
for(let i=0;i<count*3;i++) pos[i]=(Math.random()-0.5)*2000;
starsGeo.setAttribute('position',new THREE.BufferAttribute(pos,3));
const starsMat=new THREE.PointsMaterial({color:0xffffff,size:1});
scene.add(new THREE.Points(starsGeo,starsMat));

// camera controling 
let camDist=12,rotX=0.3,rotY=0.5;
function updateCam(){
    camera.position.x = camDist*Math.sin(rotY)*Math.cos(rotX);
    camera.position.y = camDist*Math.sin(rotX);
    camera.position.z = camDist*Math.cos(rotY)*Math.cos(rotX);
    camera.lookAt(0,0,0);
}
updateCam();

let dragging=false,prev={x:0,y:0};
renderer.domElement.addEventListener('mousedown',e=>{dragging=true;prev={x:e.clientX,y:e.clientY};});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
    if(!dragging)return;
    const dx=e.clientX-prev.x,dy=e.clientY-prev.y;
    rotY+=dx*0.01;rotX+=dy*0.01;
    rotX=Math.max(-Math.PI/2,Math.min(Math.PI/2,rotX));
    prev={x:e.clientX,y:e.clientY};
    updateCam();
});
window.addEventListener('wheel',e=>{
    camDist+=e.deltaY*0.01;
    camDist=Math.max(6,Math.min(40,camDist));
    updateCam();
});

// controls
const autoRotate=document.getElementById("autoRotate");
const speedSlider=document.getElementById("speedSlider");
document.getElementById("resetCam").addEventListener("click",()=>{
    camDist=12;rotX=0.3;rotY=0.5;updateCam();
});

// button for atmosphere and surface texture 
const toggleBtn = document.getElementById("toggleView");
let currentView = 'surface';
toggleBtn.addEventListener('click',()=>{
    if(currentView === 'surface'){
        venusMat.map = atmosphereTexture;
        venusMat.needsUpdate = true;
        glow.visible = true;
        toggleBtn.innerText = "Switch to Surface View";
        currentView = 'atmosphere';
    } else {
        venusMat.map = surfaceTexture;
        venusMat.needsUpdate = true;
        glow.visible = false;
        toggleBtn.innerText = "Switch to Atmosphere View";
        currentView = 'surface';
    }
});

// animation of rotation of a planet
function animate(){
    requestAnimationFrame(animate);
    const speed=parseFloat(speedSlider.value);
    if(autoRotate.checked) venus.rotation.y -= 0.0007*speed; // retrograde
    renderer.render(scene,camera);
}
animate();

// zoom functionality
window.addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
